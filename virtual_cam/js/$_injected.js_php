// $_injected.js_php - JavaScript with PHP macros for Daves Virtual Webcam
// (c)2022 David C. Walley. Released under version 3 of the GNU General Public License (GPLv3). 
// Refactoring of https://github.com/spite/virtual-webcam

// Shader          = a program running on a GPU.
// Vertex Shader   = 1st part of GPU program - In 3-D rendering program, this code is run in parallel on a per-triangle-vertex order.
// Fragment Shader = 2nd part of GPU program - In 3-D rendering program, this code is run more-or-less on a per-output pixel order. Do as much work as you can in the vertex shader, rather than in the fragment shader. 


/*DEV*/ function                        G_ASSERT(/////////////////////////////////////////////////////////# Power comments during development.
/*DEV*/                                 a_b                                                             //# Must be true,
/*DEV*/ ,                               a_s                                                             //# otherwise display the following message and halt.
/*DEV*/ ){                              //////////////////////////////////////////////////////////////////# Report nothing.
/*DEV*/  if( a_b ){                                                                             return;}//> If true then there is no problem.
/*DEV*/  console.log( a_s );                                                                            //> DEBUG info on failure - user message
/*DEV*/  console.trace();                                                                               //> DEBUG info on failure.
/*DEV*/  debugger;                                                                                      //> Switch to browser's debug mode? https://stackoverflow.com/questions/9298839/is-it-possible-to-stop-javascript-execution#9298915
/*DEV*/ }//G_ASSERT///////////////////////////////////////////////////////////////////////////////////////>


const                                   N                       = "\n";                                 //> Newline. Used in GPU code to make error messages easier to understand.

const                                   g_sCodeVertexShader     =                                       //> Vertex shader GLSL code, for execution on the GPU...
 'attribute vec4 '                      +'attributePosition;'                                        +N //> DEPRECATED 'attribute' qualifier is effectively equivalent to an input qualifier in vertex shaders. It cannot be used in any other shader stage. It cannot be used in interface blocks.
                                                                                                        //>
+'void '                                +'main('// /// // // // // // // // // // // // // // // // // ///>
+'){'+N                                 // // // // // // // // // // // // // // // // // // // // // ///>
+ 'gl_Position = attributePosition;'                                                                 +N //> gl_Position is intended for writing the homogeneous vertex position at any time during vertexshader execution. Will be used by primitive assembly, clipping, culling, and other fixed functionality operations, if present, that operate on primitives after vertex processing has occurred.
+'}'+N// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // ////>
;                                                                                                       // /*DEV*/console.log( g_sCodeVertexShader );


const                                   g_dFLAGSIZEX            = 0.4 ;                                 //>
const                                   g_dFLAGSIZEY            = 0.35;                                 //>
const                                   g_dOPACITY              = 0.6 ;                                 //>
const                                   g_sCodeFragmentShader   =                                       //> Fragment shader GLSL code for execution on the GPU...
 'precision lowp float;'                                                                             +N //> Don't seem to need highest available precision. ???Doesn't fix problem with passing in the current time?
+'uniform vec2 '                        +'uniformvec2CanvasSize;'                                    +N //> Size of the output canvas passed in.
+'uniform float '                       +'uniformfNow_ms;'                                           +N //>
+'uniform sampler2D '                   +'uniformsampler2d0;'                                        +N //> Texture unit 0 (oF at least 8) is video input (because?). sampler2D is just a way to get data from an array.   https://stackoverflow.com/questions/63322297/what-are-the-use-cases-of-sampler2d-uniforms-in-webgl-opengl
+'uniform sampler2D '                   +'uniformsampler2d1;'                                        +N //> Texture unit 1
                                                                                                        //>
+'void '                                +'main('// /// // // // // // // // // // // // // // // // // ///> Takes gl_FragCoord,
+'){'+N                                 // // // // // // // // // // // // // // // // // // // // // ///> Changes gl_FragColor.
+ 'float '                              +'u0 = gl_FragCoord.x/uniformvec2CanvasSize.x;'              +N //> Convert pixel co-
+ 'float '                              +'v0 = gl_FragCoord.y/uniformvec2CanvasSize.y;'              +N //> ordinates to a range of 0 to 1.
+ 'float '                              +'u1 = 0.0;'                                                 +N //> Co-
+ 'float '                              +'v1 = 0.0;'                                                 +N //> ordinates within texture (image).
                                                                                                        //>
+ 'float '                              +'r0 = texture2D( uniformsampler2d0 ,vec2(u0 ,v0) ).r;'      +N //> deprecated. Retrieves texels from texture uniformsampler2d0 (video feed), including the Red
+ 'float '                              +'g0 = texture2D( uniformsampler2d0 ,vec2(u0 ,v0) ).g;'      +N //> Green and
+ 'float '                              +'b0 = texture2D( uniformsampler2d0 ,vec2(u0 ,v0) ).b;'      +N //> Blue values of the pixel.
                                                                                                        //>
+ 'float '                              +'r1 = 0.0;'                                                 +N //> deprecated. Retrieves texels from texture uniformsampler2d1
+ 'float '                              +'g1 = 0.0;'                                                 +N //>
+ 'float '                              +'b1 = 0.0;'                                                 +N //>
+ 'float '                              +'dFlutter = 0.0;'                                           +N //> ".
+ 'float '                              +'dSun = 3.0*dFlutter;'                                      +N //> Lightness to add to create a 3-D highlight effect on the flag.
+ 'bool '                               +'bSideL_NotR '         +'= true;'                           +N //> TODO
+ 'bool '                               +'bFlip '               +'= false;'                          +N //> TODO
+ 'if( bSideL_NotR ){'                                                                               +N //>
+  'dFlutter = (0.06 *sin( 11.0*(u0 - 0.4*uniformfNow_ms) )'                                            //> "
+             '+0.037*sin( 15.3*(u0 - 0.9*uniformfNow_ms) )'                                            //> "
+             '+0.029*sin( 22.3*(u0 - 1.3*uniformfNow_ms) )'                                            //> ".
+             ');'                                                                                   +N //> ".
+  'dFlutter *= -u0;'                                                                                   //>
+  'dSun = 3.0*dFlutter;'                                                                            +N //> Lightness to add to create a 3-D highlight effect on the flag.
                                                                                                        //>
+  'if(  u0 < '+    g_dFLAGSIZEX            +' ){'                                                   +N //> If in right corner (0.6 of full display width),
+   'if( v0 < '+    g_dFLAGSIZEY +' + dFlutter ){'                                                   +N //> and if at bottom (bottom 35% plus flutter)
+    'u1 = ( u0 '        +')*'+ ( 1/g_dFLAGSIZEX  ).toFixed(5) +';'                                  +N //>  + ?
+    'v1 = ( v0 - dFlutter )*'+ ( 1/g_dFLAGSIZEY  ).toFixed(5) +';'                                  +N //> 1/0.3
+    'if( v1 < 0.0 ){ gl_FragColor = vec4(r0 ,g0 ,b0 ,1.0);'                               +'return;}'+N//>
+    'if( bFlip ){ u1 = 1.0 - u1; }'                                                                 +N //>
+    'r1 = texture2D( uniformsampler2d1 ,vec2(u1 ,v1) ).r;'                                          +N //> deprecated. Retrieves texels from texture uniformsampler2d1
+    'g1 = texture2D( uniformsampler2d1 ,vec2(u1 ,v1) ).g;'                                          +N //>
+    'b1 = texture2D( uniformsampler2d1 ,vec2(u1 ,v1) ).b;'                                          +N //>
+    'gl_FragColor = vec4(r1*'+ g_dOPACITY.toFixed(5) +' + r0*'+ (1 - g_dOPACITY).toFixed(5) +' + dSun' //> Calculate mixture of flag and video,
+                       ',g1*'+ g_dOPACITY.toFixed(5) +' + g0*'+ (1 - g_dOPACITY).toFixed(5) +' + dSun' //> plus adjust brightness to give flag a 3-D effect
+                       ',b1*'+ g_dOPACITY.toFixed(5) +' + b0*'+ (1 - g_dOPACITY).toFixed(5) +' + dSun' //> "
+                       ',1.0'                                                                          //> Completely opaque result
+                       ');'                                                                         +N //> .
+ 'return;'                                                                                          +N //> We are done in this case.
+  '}}'//if//if                                                                                      +N //> .
+ '}else{'                                                                                              //>
+  'dFlutter = (0.06 *sin( 11.0*(u0 + 0.4*uniformfNow_ms) )'                                            //> "
+             '+0.037*sin( 15.3*(u0 + 0.9*uniformfNow_ms) )'                                            //> "
+             '+0.029*sin( 22.3*(u0 + 1.3*uniformfNow_ms) )'                                            //> ".
+             ');'                                                                                   +N //> ".
+  'dFlutter *= (1.0 - u0);'                                                                            //>
+  'dSun = 3.0*dFlutter;'                                                                            +N //> Lightness to add to create a 3-D highlight effect on the flag.
+  'if( '+     (1 - g_dFLAGSIZEX) +' < u0 ){'                                                        +N //> If in right corner (0.6 of full display width),
+   'if( v0 < '+    g_dFLAGSIZEY  +' + dFlutter ){'                                                  +N //> and if at bottom (bottom 35% plus flutter)
                                                                                                        //>
+    'u1 = ( u0 - '+ (1 - g_dFLAGSIZEX) +' )*'+   ( 1/g_dFLAGSIZEX  ).toFixed(5)   +';'              +N //>  + ?
+    'v1 = ( v0 - dFlutter'+           ' )*'+   ( 1/g_dFLAGSIZEY  ).toFixed(5)   +';'                +N //> 1/0.3
+    'if( v1 < 0.0 ){ gl_FragColor = vec4(r0 ,g0 ,b0 ,1.0);'                               +'return;}'+N//>
+    'if( bFlip ){ u1 = 1.0 - u1; }'                                                                 +N //>
+    'r1 = texture2D( uniformsampler2d1 ,vec2(u1 ,v1) ).r;'                                          +N //> deprecated. Retrieves texels from texture uniformsampler2d1
+    'g1 = texture2D( uniformsampler2d1 ,vec2(u1 ,v1) ).g;'                                          +N //>
+    'b1 = texture2D( uniformsampler2d1 ,vec2(u1 ,v1) ).b;'                                          +N //>
+    'gl_FragColor = vec4(r1*'+ g_dOPACITY.toFixed(5) +' + r0*'+ (1 - g_dOPACITY).toFixed(5) +' + dSun' //> Calculate mixture of flag and video,
+                       ',g1*'+ g_dOPACITY.toFixed(5) +' + g0*'+ (1 - g_dOPACITY).toFixed(5) +' + dSun' //> plus adjust brightness to give flag a 3-D effect
+                       ',b1*'+ g_dOPACITY.toFixed(5) +' + b0*'+ (1 - g_dOPACITY).toFixed(5) +' + dSun' //> "
+                       ',1.0'                                                                          //> Completely opaque result
+                       ');'                                                                         +N //> .
+ 'return;'                                                                                          +N //> We are done in this case.
+ '}}}'//if//if//if                                                                                     //>
                                                                                                     +N //> Otherwise
+ 'gl_FragColor = vec4(r0 ,g0 ,b0 ,1.0);'                                                            +N //> copy color as is.
+'}'+N//main// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // ////>
;                                                                                                       //> /*DEV*/console.log( g_sCodeFragmentShader );


class                                   ShaderRenderer////////////////////////////////////////////////////#
{/////////////////////////////////////////////////////////////////////////////////////////////////////////>
                                                                                                        //>
                                        NewImage(/////////////////////////////////////////////////////////>
                                        a_sFlagIn
 ){                                     //////////////////////////////////////////////////////////////////>
  const                                 me                      = this;                                 /*DEV*/G_ASSERT( 'ShaderRenderer' === me.constructor.name ,'me bad "'+ me.constructor.name +'"');//> Code clarity. Remember this for making a clear reference to the object being constructed in callbacks.
  me._eleFlagIn     = null       ;                                                                      //> Just to be clear - destroy any previous data.
  me._eleFlagIn     = new Image();                                                                      //> Image constructor
  me._eleFlagIn.src = a_sFlagIn  ;                                                                      //> Source of flag graphic.
 }//NewImage//////////////////////////////////////////////////////////////////////////////////////////////>


                                        constructor(//ShaderRenderer//////////////////////////////////////# Create instance of ShaderRenderer - the connection to the GPU.
                                        a_eleCanvasOut                                                  //# Given a canvas DOM element (for output of GPU?), and
 ,                                      a_eleVideoIn                                                    //# video DOM element (for input data?)
 ,                                      a_sFlagIn                                                       //#
 ){                                     //////////////////////////////////////////////////////////////////#
  const                                 me                      = this;                                 /*DEV*/G_ASSERT( 'ShaderRenderer' === me.constructor.name ,'me bad "'+ me.constructor.name +'"');//> Code clarity. Remember this for making a clear reference to the object being constructed in callbacks.
       this._eleCanvasOut            = a_eleCanvasOut;                                                  //> private: Remember the given canvas (for output) and
       this._eleVideoIn              = a_eleVideoIn  ;                                                  //> private: video (source?).
       this._eleFlagIn               = null;                    me.NewImage( a_sFlagIn );                  //> Image constructor, source of flag graphic.
       this._g                       = me._eleCanvasOut.getContext( 'webgl'                          ); //> private: Remember the webGL object that represents the 3D graphics state and behavior of the canvas.
       this._program                 = me.createProgram(   g_sCodeVertexShader,g_sCodeFragmentShader ); //> private: Combine the 2 shaders into a complete program.
       this._textureVideoIn          = me._g.createTexture(                                          ); //> private: Creates and initializes a WebGLTexture object for the video - a named texture = an unsigned integer.
       this._textureFlagIn           = me._g.createTexture(                                          ); //> private: Creates and initializes a WebGLTexture object for the flag graphic - a named texture = an unsigned integer.
       this._uniformsampler2d0       = me._g.getUniformLocation( me._program, 'uniformsampler2d0'    ); //> Get the uniform location before the draw loop.   https://dens.website/tutorials/webgl/textures
       this._uniformsampler2d1       = me._g.getUniformLocation( me._program, 'uniformsampler2d1'    ); //> Get the uniform location before the draw loop.
       this._location_vec2CanvasSize = me._g.getUniformLocation( me._program ,'uniformvec2CanvasSize'); //> private: Image size - Remember the location of a specific uniform variable used in g_sCodeFragmentShader.
       this._location_ufNow_ms       = me._g.getUniformLocation( me._program ,'uniformfNow_ms'       ); //> private: Current time - Remember the location of a specific uniform variable used in g_sCodeFragmentShader.
       this._bufferPosition          = me._g.createBuffer(                                           ); //> private: Buffer to hold ???
       this._attriblocationPosition  = me._g.getAttribLocation(  me._program ,'attributePosition'    ); //> private: Returns the location of an attribute variable in a given WebGLProgram.   Queries the program for the vertex shader attribute variable specified, and returns the index of the generic vertex attribute bound to the attribute.
                                                                                                        //>
  me._g.bindBuffer(                  me._g.ARRAY_BUFFER        ,me._bufferPosition                   ); //> ?Binds to a target of vertex attributes (such as vertex color data), the given WebGLBuffer.
  me._g.bufferData(                  me._g.ARRAY_BUFFER                                                 //> Creates and initializes a buffer object's data store, with Vertex attributes,
  ,                                  new Float32Array( [-1, -1                                          //> A    CD.....+.....F    2 triangles making up a square.
                                                       , 1, -1                                          //> B     : .   |     :
                                                       ,-1,  1                                          //> C     :   . |     :
                                                       ,-1,  1                                          //> D  ---+-----o-----+---
                                                       , 1, -1                                          //> E     :     | .   :
                                                       , 1,  1                                          //> F     :     |   . :
                                     ]                 )                                                //>       A.....+.....BE
  ,                                  me._g.STATIC_DRAW                                                  //> Hint to the GL implementation as to how a buffer object's data store will be accessed
  );                                                                                                    //> .
 }//new ShaderRenderer////////////////////////////////////////////////////////////////////////////////////>


                                        render(//ShaderRenderer///////////////////////////////////////////#
                                        a_whenNow_ms                                                    //#
 ){                                     //////////////////////////////////////////////////////////////////#
  const                                 me                      = this;                                 /*DEV*/G_ASSERT( 'ShaderRenderer' === me.constructor.name ,'me bad "'+ me.constructor.name +'"');//> Code clarity. Remember this for making a clear reference to the object being constructed in callbacks.
  const                                 g                       = me._g;                                //> Collapse the following a bit:
                                                                                                        //>
  g.enableVertexAttribArray( me._attriblocationPosition                                              ); //> index of the generic vertex attribute bound to the attribute 'attributePosition'. attributes in a vertex shader are disabled by default. To use one, you have to first enable it with this function.
  g.bindBuffer(              g.ARRAY_BUFFER         ,me._bufferPosition                              ); //>
  g.vertexAttribPointer(     me._attriblocationPosition ,2 ,g.FLOAT ,false ,0 ,0                     ); //> Specify how to interpret data: 'attributePosition' takes 2 floats, not normalized, no offset or stride (single value)?
                                                                                                        //>
  g.activeTexture(           g.TEXTURE0                                                              ); //> Specifies which texture unit to make active (in subsequent calls?).
  g.pixelStorei(             g.UNPACK_FLIP_Y_WEBGL  ,true                                            ); //> Specifies the pixel storage modes: Flips the source data along its vertical axis if true. For some reason WebGL textures are flipped vertically in comparasion to OpenGL
  g.bindTexture(             g.TEXTURE_2D           ,me._textureVideoIn                              ); //> Bind to a texturing target (2-D plane), a named texture - an unsigned integer.
  g.texImage2D(              g.TEXTURE_2D,0    ,g.RGBA,g.RGBA ,g.UNSIGNED_BYTE   ,me._eleVideoIn     ); //> Specifies a 2-D texture image: level 0 is the base image level of detail (of a set of mipmaps?); internal format is RGBA components read from the color buffer; texel format is RGBA, 8-bit values; video DOM element is the source of data.
  g.texParameteri(           g.TEXTURE_2D           ,g.TEXTURE_MAG_FILTER    ,g.LINEAR               ); //> How it should filter upon scaling up. Set texture parameters: target is a two-dimensional texture; texture magnification filter; default.   https://dens.website/tutorials/webgl/textures
  g.texParameteri(           g.TEXTURE_2D           ,g.TEXTURE_MIN_FILTER    ,g.LINEAR               ); //> How i should filter upon scaling down. Target is a two-dimensional texture; texture minification filter; default?
  g.texParameteri(           g.TEXTURE_2D           ,g.TEXTURE_WRAP_S        ,g.CLAMP_TO_EDGE        ); //> Specify how to handle co-ords outside range - wrapping function for texture coordinate s.
  g.texParameteri(           g.TEXTURE_2D           ,g.TEXTURE_WRAP_T        ,g.CLAMP_TO_EDGE        ); //> Specify how to handle co-ords outside range - wrapping function for texture coordinate t.
                                                                                                        //>
  g.activeTexture(           g.TEXTURE1                                                              ); //> Specifies which texture unit to make active (in subsequent calls?).
  g.pixelStorei(             g.UNPACK_FLIP_Y_WEBGL  ,true                                            ); //> Specifies the pixel storage modes: Flips the source data along its vertical axis if true. For some reason WebGL textures are flipped vertically in comparasion to OpenGL
  g.bindTexture(             g.TEXTURE_2D           ,me._textureFlagIn                               ); //> Bind to a texturing target (2-D plane), a named texture - an unsigned integer.
  g.texImage2D(              g.TEXTURE_2D                                                               //> Specifies a 2-D texture image:   
  ,                          0                                                                          //> level 0 is the base image level of detail (of a set of mipmaps);
  ,                          g.RGBA                                                                     //> internal format is RGBA components read from the color buffer;
  ,                          g.RGBA                                                                     //> texel format is RGBA, 
  ,                          g.UNSIGNED_BYTE                                                            //> 8-bit values; 
  ,                          me._eleFlagIn                                                              //> DOM element is the source of data.
  );                                                                                                    //>
  g.texParameteri(           g.TEXTURE_2D           ,g.TEXTURE_MAG_FILTER    ,g.LINEAR               ); //> Set texture parameters: target is a two-dimensional texture; texture magnification filter; default.
  g.texParameteri(           g.TEXTURE_2D           ,g.TEXTURE_MIN_FILTER    ,g.LINEAR               ); //> Target is a two-dimensional texture; texture minification filter; default?
  g.texParameteri(           g.TEXTURE_2D           ,g.TEXTURE_WRAP_S        ,g.CLAMP_TO_EDGE        ); //> Specify how to handle co-ords outside range - wrapping function for texture coordinate s.
  g.texParameteri(           g.TEXTURE_2D           ,g.TEXTURE_WRAP_T        ,g.CLAMP_TO_EDGE        ); //> Specify how to handle co-ords outside range - wrapping function for texture coordinate t.
                                                                                                        //>
  g.useProgram(              me._program                                                             ); //> Sets the specified WebGLProgram as part of the current rendering state (must preceed the following...)
  g.uniform1i(               me._uniformsampler2d0 ,0 );                                                //> Bind our texture to texture unit 0.
  g.uniform1i(               me._uniformsampler2d1 ,1 );                                                //> Bind our texture to texture unit 1.
  g.uniform1f(               me._location_ufNow_ms                                                      //> Pass in the current time.
  ,                          ( Date.now()%100000 )*0.0001                                               //> ???Overcome  some kind of number format issue - can't seem to pass in a float as is?
  );                                                                                                    //>
  g.uniform2f(               me._location_vec2CanvasSize                                                //> Specify values of uniform variables - pass into GPU program, 2 float values for:
  ,                          g.canvas.width                                                             //> the size of the image
  ,                          g.canvas.height                                                            //> "
  );                                                                                                    //> .
  g.drawArrays(              g.TRIANGLES ,0 ,6                                                       ); //> Render primitives from array data, 0 is index, 6 indices to be rendered (2 triangles in rectangle?)
 }//ShaderRenderer.render/////////////////////////////////////////////////////////////////////////////////>


                                        CompileShader(//ShaderRenderer////////////////////////////////////#
                                        a_sCode                                                         //# GSLS code to be compiled.
 ,                                      type                                                            //# Vertex or Fragment.
 ){                                     //////////////////////////////////////////////////////////////////#
  const                                 me                      = this;                                 /*DEV*/G_ASSERT( 'ShaderRenderer' === me.constructor.name ,'me bad "'+ me.constructor.name +'"');//> Code clarity. Remember this for making a clear reference to the object being constructed in callbacks.
  const                                 r_shader                = me._g.createShader(type);             //> Creates a WebGLShader that can then be configured further using shaderSource() and compileShader().
  me._g.shaderSource(           r_shader ,a_sCode               );                                      //>
  me._g.compileShader(          r_shader                        );                                      //>
  if( me._g.getShaderParameter( r_shader ,me._g.COMPILE_STATUS) ){                     return r_shader;}//> If compilation was successful (which can be different for different GPUs), then we are done.
  var                                   info                    = me._g.getShaderInfoLog(r_shader);     //> If there was a problem, then get error message and
  /*DEV*/ G_ASSERT(   false ,"Could not compile WebGL program. \n\n"+ info   );                         //> report the error while halting.
 }//ShaderRenderer.CompileShader//////////////////////////////////////////////////////////////////////////>


                                        createProgram(//ShaderRenderer////////////////////////////////////#
                                        a_sShaderVertex                                                 //#
 ,                                      a_sShaderFragment                                               //#
 ){                                     //////////////////////////////////////////////////////////////////#
  const                                 me                      = this;                                 /*DEV*/G_ASSERT( 'ShaderRenderer' === me.constructor.name ,'me bad "'+ me.constructor.name +'"');//> Code clarity. Remember this for making a clear reference to the object being constructed in callbacks.
  const                   vertexShader   = me.CompileShader( a_sShaderVertex   ,me._g.VERTEX_SHADER  ); //>
  const                   fragmentShader = me.CompileShader( a_sShaderFragment ,me._g.FRAGMENT_SHADER); //>
  var                     program        = me._g.createProgram();                                       //>
  me._g.attachShader( program ,vertexShader   );                                                        //>
  me._g.attachShader( program ,fragmentShader );                                                        //>
  me._g.linkProgram(  program                 );                                                        //>
  var                                   success                 = me._g.getProgramParameter(            //>
                                                                   program                              //>
                                                                  ,me._g.LINK_STATUS                    //>
                                                                  );                                    //>
  if( success ){                                                                        return program;}//>
  /*DEV*/console.log( me._g.getProgramInfoLog(program) );                                               //> Report error.
  me._g.deleteProgram( program );                                                                       //>
 }//ShaderRenderer.createProgram//////////////////////////////////////////////////////////////////////////>


                                        setSize(//ShaderRenderer//////////////////////////////////////////#
                                        a_nW                                                            //#
 ,                                      a_nH                                                            //#
 ){                                     //////////////////////////////////////////////////////////////////#
  const                                 me                      = this;                                 /*DEV*/G_ASSERT( 'ShaderRenderer' === me.constructor.name ,'me bad "'+ me.constructor.name +'"');//> Code clarity. Remember this for making a clear reference to the object being constructed in callbacks.
  me._eleCanvasOut.width  = a_nW;                                                                       //>
  me._eleCanvasOut.height = a_nH;                                                                       //>
  me._g.viewport(0 ,0  ,a_nW ,a_nH);                                                                    //>
 }//ShaderRenderer.setSize////////////////////////////////////////////////////////////////////////////////>

                                                                                                        //>
}//class ShaderRenderer///////////////////////////////////////////////////////////////////////////////////>
//////////////////////////////////////////////////////////////////////////////////////////////////////////>




let                                     g_shaderrenderer        = null;                                 //> 

function                                Tick(//FilterStream///////////////////////////////////////////////# Periodic routine.
){                                      //////////////////////////////////////////////////////////////////#
 g_shaderrenderer.render();                                                                             //> Use a WebGL renderer.
 requestAnimationFrame(   function(){ Tick(); }   );                                                    //> Run this periodic routine again.
}//Tick///////////////////////////////////////////////////////////////////////////////////////////////////>


async function                          ModifyMediaFunctions(/////////////////////////////////////////////#
){                                      //////////////////////////////////////////////////////////////////#
                                                                                                        //>
                                                                                                        //>
 const                                  enumerateDevicesWas  = MediaDevices.prototype.enumerateDevices; //> Get existing version of system function to get a list of cameras.
 MediaDevices['prototype']            ['enumerateDevices'] = async function(// // // // // // // // // // // // // ///# Redefine this system function locally, to include the virtual camera.
 ){                                     // // // // // // // // // // // // // // // // // // // // // ///#
  const                                result = await enumerateDevicesWas.call(navigator.mediaDevices); //> Get all the current cameras (should not include the virtual camera?)
  const                                x                = {'deviceId' : 'virtual'                       //>
                                                          ,'groupID'  : 'uh'                            //>
                                                          ,'kind'     : 'videoinput'                    //>
/*DEV*/                                                   ,'label'    : 'DEV Virtual Webcam'            //>
//*PRO*/                                                  ,'label'    : 'Slavi Ukraini Virtual Webcam'  //>
                                                          }                                             //>
  result.push( /** @type {!MediaDeviceInfo|!undefined} */ (x) );                                        //> Append new device info to the list. We could add "Virtual VHS" or "Virtual Median Filter" and map devices with filters. @type is required to get past a Closure Compiler error.
 return result;                                                                                         //> Report the new list.
 };//enumerateDevices// // // // // // // // // // // // // // // // // // // // // // // // // // // ////>
                                                                                                        //>
                                                                                                        //>
 const                                  getUserMediaWas         = MediaDevices.prototype.getUserMedia;  //> Get existing version of system function to get a camera's video stream.
 MediaDevices['prototype']            ['getUserMedia'] = async function(// // // // // // // // // // ////# Redefine this system function locally, to include the virtual camera.
 ){                                     // // // // // // // // // // // // // // // // // // // // // ///#
  const                                 args                    = arguments;                            //>
  if(   args.length   &&   args[0].video   &&   args[0].video.deviceId   ){                             //>
   if( 'virtual' === args[0].video.deviceId                                                             //>
    || 'virtual' === args[0].video.deviceId.exact                                                       //>
   ){                                                                                                   //>
    const                               usermedia = await getUserMediaWas.call(                         //>
                                                           navigator.mediaDevices                       //>
                                                          ,{video : {facingMode: args[0].facingMode     //> This constraints could mimic closely the request. Also, there could be a preferred webcam on the options. Right now it defaults to the predefined input.
                                                                    ,advanced  : args[0].video.advanced //>
                                                                    ,width     : args[0].video.width    //>
                                                                    ,height    : args[0].video.height   //>
                                                                    }                                   //>
                                                           ,audio : false                               //> No audio.
                                                          });                                           //>
    if( usermedia ){                                                                                    //> If devices found?, then
     const                              eleCanvas            = document.createElement( 'canvas' );      //>
     const                              eleVideo             = document.createElement( 'video'  );      //>

     eleVideo.srcObject = usermedia;                                                                    //>
     eleVideo.autoplay  = true;                                                                         //>
// TODO Shut down and restart g_shaderrenderer???
                           g_shaderrenderer = new ShaderRenderer(eleCanvas ,eleVideo ,g_sFLAG_UKRAINE); //> Create instance of ShaderRenderer - the connection to the GPU.
//                         g_shaderrenderer = new ShaderRenderer(eleCanvas ,eleVideo ,g_sFLAG_CANADA ); //>
//                         g_shaderrenderer = new ShaderRenderer(eleCanvas ,eleVideo ,g_sFLAG_USA    ); //>
//                         g_shaderrenderer = new ShaderRenderer(eleCanvas ,eleVideo ,g_sFLAG_UK     ); //>
//                         g_shaderrenderer = new ShaderRenderer(eleCanvas ,eleVideo ,g_sFLAG_RAINBOW); //>
//                         g_shaderrenderer = new ShaderRenderer(eleCanvas ,eleVideo ,g_sFLAG_CHILD  ); //>
//                         g_shaderrenderer = new ShaderRenderer(eleCanvas ,eleVideo ,g_sFLAG_JAMAICA); //>
//                         g_shaderrenderer = new ShaderRenderer(eleCanvas ,eleVideo ,g_sFLAG_PIRATE ); //>
     eleVideo.addEventListener('playing'                                                                //>
     ,                         function(){                                                              //> Use a 2D Canvas. me.canvas.width = me.video.videoWidth; me.canvas.height = me.video.videoHeight;                               //>
                                g_shaderrenderer.setSize( eleVideo.videoWidth ,eleVideo.videoHeight );  //> Use a WebGL Renderer.
                                Tick();                                                                 //> Start periodic routine
     }                         );                                                                       //> .

 return eleCanvas.captureStream();                                                                      //> Get a real-time video capture of the surface of the canvas.
    }//if                                                                                               //>
    // ??? What happens now, if fullfilledpromiseMediaStream was null?                                  //>
  }}//if virtual//if                                                                                    //>
                                                                                                        //>
  const                            fullfilledpromiseMediaStream = await getUserMediaWas.call(           //>
                                                                   navigator.mediaDevices               //>
                                                                  ,...arguments                         //>
                                                                  );                                    //>
 return fullfilledpromiseMediaStream;                                                                   //>
 };//function// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // ///>
                                                                                                        //>
}//ModifyMediaFunctions///////////////////////////////////////////////////////////////////////////////////>


ModifyMediaFunctions();                                                                                 //> Add virtual camera to system's list of cameras.

// include data file somehow?
// <?php echo 'console.log("hers jo");'; ?> PHP Not working live when script1.setAttribute( 'src' ,window['chrome']['runtime']['getURL']('js/$_injected.js_php') )?
/*DEV*/ G_ASSERT( g_sFLAG_PIRATE ,"g_sFLAG_PIRATE should be defined." ); //> Defined live, need to include some other way for PRO?


//End of file.